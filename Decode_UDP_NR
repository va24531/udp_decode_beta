[{"id":"f848aedb.a536d8","type":"tab","label":"Full Decode Of JTDX Packets","disabled":false,"info":""},{"id":"4ff1b199.57fd08","type":"udp in","z":"f848aedb.a536d8","name":"","iface":"","port":"2237","ipv":"udp4","multicast":"false","group":"","datatype":"buffer","x":200,"y":220,"wires":[["847c048.22ce478"]]},{"id":"847c048.22ce478","type":"function","z":"f848aedb.a536d8","name":"","func":"// makes duplicate copy of orig message, so it can be passed on further down the line\n// without accidently overwriting it.\n// ---------------------------------------------------------------------------------------\n\nmsg.orig_message = msg.payload;\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":400,"y":220,"wires":[["39081c81.87119c"]]},{"id":"760f003f.fa4df8","type":"link out","z":"f848aedb.a536d8","name":"WSJT Message Output","links":["8f371112.7b051"],"x":895,"y":440,"wires":[]},{"id":"86551151.bbfe18","type":"function","z":"f848aedb.a536d8","name":"Decoded RX QSO Message","func":"// msg.decoded_msg_type \n// msg.new_decode (0/1)\n// msg.decode_time (ms since midnight UTC, as reported by UDP Packet)\n// msg.snr_report ( very useful for new contact/grid/county alert trigger. No need to notify if signal is very weak)\n// msg.mode_string (~ is ft8)\n// msg.qso_message_ascii - full decoded message, nothing more, nothing less. string trimming is done in post-processing\n// msg.confidence_int (0/1)\n// msg.offline_int (0/1)\n\n// More disabled messages available at end of function.\n\n//live example:\n// -------------------------------------\n// payload: \" New Message \"\n// fromip: \"127.0.0.1:59005\"\n// ip: \"127.0.0.1\"\n// port: 59005\n// _msgid: \"181fe13b.f404cf\"\n// orig_message: buffer[66]\n// decode_msg_type: 2\n// magicpacket: \"adbccbda\"\n// version: 2\n// packet_type: 2\n// sw_name: \"JTDX\"\n// new_decode: 1\n// decode_time: 63315000\n// snr_report: -17\n// mode_string: \"~\"\n// qso_message_ascii: \"4L8A PY7YZ -15\"\n// confidence_int: 0\n// offline_int: 0\n// -------------------------------------\n\n\n\n\n\n// Do NOT Modify! -------------------------------------------------------------\n        function hexToInt(hex) {\n            if (hex.length % 2 != 0) {\n                hex = \"0\" + hex;\n            }\n            var num = parseInt(hex, 16);\n            var maxVal = Math.pow(2, hex.length / 2 * 8);\n            if (num > maxVal / 2 - 1) {\n                num = num - maxVal\n            }\n            return num;\n        }\n\n\n        // Creation of a function to get the Hex Value from a message\n        function* hexFormatValues(buffer) {\n            for (let x of buffer) {\n                const hex = x.toString(16)\n                yield hex.padStart(2, '0')\n            }\n        }\n\n\n        msg.payload = msg.orig_message;\n\n            // Variable declaration for my loop\n                var string = \"\"\n                const buf = Buffer.from(msg.payload)\n\n            // Concatenation of the buffer in a string \n                for (let hex of hexFormatValues(buf)) {string = string + hex } \n\n            //msg.payload = string;\n\n// Do NOT Modify! -------------------------------------------------------------\n\n\nplaceholder_start = 0;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nmagic_packet = string.substring(placeholder_start,placeholder_stop);\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nversion = parseInt(string.substring(placeholder_start,placeholder_stop));\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\npacket_type = parseInt(string.substring(placeholder_start,placeholder_stop));\n\n\nif (packet_type !== 2){  msg.other_decode = string; return msg;} // Stop Here If Not A Decode Message!\n\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\n\nsw_size = string.substring(placeholder_start,placeholder_stop); // Decode Length Of Software Name (wsjt-x vs jtdx vs whatever)\nsw_name_length = placeholder_start  + next_value_length + (parseInt(sw_size) * 2); // Convert hex value to true interger value, double it, and add it to the last hex position of 32\nsw_name = string.substring(32,sw_name_length);      // Get hex of software name, length based on above\n\n    var hex  = sw_name.toString();\n\tvar sw_name_2 = '';\n    for (var n = 0; n < hex.length; n += 2) { sw_name_2 += String.fromCharCode(parseInt(hex.substr(n, 2), 16));}\n\t// Convert software name from hex to ascii \n\nplaceholder_start = sw_name_length;\nnext_value_length = 2;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_new_decode = string.substring(placeholder_start, placeholder_stop);\nint_new_decode = parseInt(hex_new_decode);\n\n// Decoded Milliseconds After Midnight UTC\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_decode_time = string.substring(placeholder_start,placeholder_stop);\nreal_decode_time = hexToInt(hex_decode_time);\n// Decoded Milliseconds After Midnight UTC\n\n\n\n// Signal-Noise-Ratio\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_snr_report = string.substring(placeholder_start,placeholder_stop);\nreal_snr_value = hexToInt(hex_snr_report);\n// Signal-Noise-Ratio\n\n\n\n// Delta Time\nplaceholder_start = placeholder_stop;\nnext_value_length = 16;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_delta_time = string.substring(placeholder_start,placeholder_stop);\n\n// Delta Time\n\n\n// Delta Frequency\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_delta_freq = string.substring(placeholder_start,placeholder_stop);\n// Delta Frequency\n\n\n// Mode\nplaceholder_start = placeholder_stop;\nnext_value_length = 10;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_mode = string.substring(placeholder_start,placeholder_stop);\n\n    var hex_mode_string  = hex_mode.toString();\n\tvar string_mode = '';\n    for (n = 0; n < hex_mode_string.length; n += 2) { string_mode += String.fromCharCode(parseInt(hex_mode_string.substr(n, 2), 16));}\n\t// Convert software name from hex to ascii \n// Mode\n\n\n// Actual Message Length\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_qso_message_length = string.substring(placeholder_start,placeholder_stop);\nint_qso_message_length = parseInt(hex_qso_message_length,16);\n\n// Actual Message Length\n\n\n// Actual Message\n\nplaceholder_start = placeholder_stop;\nnext_value_length = int_qso_message_length * 2;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_qso_message = string.substring(placeholder_start,placeholder_stop);\n\n\n    var hex_message_convert  = hex_qso_message.toString();\n\tvar ascii_message = '';\n    for (n = 0; n < hex_message_convert.length; n += 2) { ascii_message += String.fromCharCode(parseInt(hex_message_convert.substr(n, 2), 16));}\n\t// Convert software name from hex to ascii\n\n// Actual Message\n\n\n\n// Low Confidence\nplaceholder_start = placeholder_stop;\nnext_value_length = 2;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_confidence = string.substring(placeholder_start,placeholder_stop);\nint_confidence = parseInt(hex_confidence);\n// Low Confidence\n\n\n// Off Air \nplaceholder_start = placeholder_stop;\nnext_value_length = 2;\nplaceholder_stop = placeholder_start + next_value_length;\nhex_offline = string.substring(placeholder_start,placeholder_stop);\nint_offline = parseInt(hex_offline);\n// Off Air\n\n\nmsg.magicpacket = magic_packet;\nmsg.version = version;\nmsg.packet_type = packet_type;\nmsg.sw_name = sw_name_2;\nmsg.new_decode = int_new_decode;\n//msg.decode_time_hex = hex_decode_time;\nmsg.decode_time = real_decode_time;\n//msg.snr_report_hex = hex_snr_report;\nmsg.snr_report = real_snr_value;\n//msg.delta_time_hex = hex_delta_time;\n//msg.delta_freq_hex = hex_delta_freq;\n//msg.mode_hex = hex_mode;\nmsg.mode_string = string_mode;\n//msg.qso_message_length_hex = hex_qso_message_length;\n//msg.qso_message_length_int = int_qso_message_length;\n//msg.qso_message = hex_qso_message;\nmsg.qso_message_ascii = ascii_message;\n\n//msg.confidence_hex = hex_confidence;\nmsg.confidence_int = int_confidence;\n//msg.offline_hex = hex_offline;\nmsg.offline_int = int_offline;\n\n//msg.packet_length = string.length;\n//msg.full_packet = string;\n\nmsg.payload = ' New Message ';\n\n\nreturn msg;\n\n\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":660,"y":420,"wires":[["760f003f.fa4df8","c81b62e8.5cb908"]]},{"id":"39081c81.87119c","type":"function","z":"f848aedb.a536d8","name":"DO NOT MODIFY!","func":"// This section ONLY decodes what type of packet it is, and handles it as either a type 0, 1, or 2, as per protocol\n// Nothing useful returned here, except      msg.decode_msg_type\n// ------------------------------------------------------------------------------------------------------------------\n\n// Do NOT Modify! -------------------------------------------------------------\n        function hexToInt(hex) {\n            if (hex.length % 2 != 0) { hex = \"0\" + hex; }\n            var num = parseInt(hex, 16);\n            var maxVal = Math.pow(2, hex.length / 2 * 8);\n            if (num > maxVal / 2 - 1) { num = num - maxVal }\n            return num;\n        }\n\n        function* hexFormatValues(buffer) {\n            for (let x of buffer) { const hex = x.toString(16); yield hex.padStart(2, '0'); }\n        }\n\n        msg.payload = msg.orig_message;\n\n                var string = \"\";\n                const buf = Buffer.from(msg.payload);\n\n                for (let hex of hexFormatValues(buf)) {string = string + hex } \n\nplaceholder_start = 0;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nmagic_packet = string.substring(placeholder_start,placeholder_stop);\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nversion = parseInt(string.substring(placeholder_start,placeholder_stop));\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\npacket_type = parseInt(string.substring(placeholder_start,placeholder_stop));\n\n\nmsg.decode_msg_type = packet_type;\nreturn msg;\n\n// Do NOT Modify! -------------------------------------------------------------","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":210,"y":320,"wires":[["267c1c5a.6e80dc"]]},{"id":"267c1c5a.6e80dc","type":"switch","z":"f848aedb.a536d8","name":"","property":"decode_msg_type","propertyType":"msg","rules":[{"t":"eq","v":"0","vt":"num"},{"t":"eq","v":"1","vt":"num"},{"t":"eq","v":"2","vt":"num"}],"checkall":"true","repair":false,"outputs":3,"x":410,"y":320,"wires":[["9e71d881.30f958"],["2e3e4f72.0798d"],["86551151.bbfe18"]]},{"id":"9e71d881.30f958","type":"function","z":"f848aedb.a536d8","name":"Decode Heartbeat Message","func":"// Standard heartbeat message\n// Only thing really useful in this packet is sw_name, nothing else.\n\n\n\n\n// Do NOT Modify! -------------------------------------------------------------\n        function hexToInt(hex) {\n            if (hex.length % 2 != 0) {\n                hex = \"0\" + hex;\n            }\n            var num = parseInt(hex, 16);\n            var maxVal = Math.pow(2, hex.length / 2 * 8);\n            if (num > maxVal / 2 - 1) {\n                num = num - maxVal\n            }\n            return num;\n        }\n\n\n        // Creation of a function to get the Hex Value from a message\n        function* hexFormatValues(buffer) {\n            for (let x of buffer) {\n                const hex = x.toString(16)\n                yield hex.padStart(2, '0')\n            }\n        }\n\n\n        msg.payload = msg.orig_message;\n\n            // Variable declaration for my loop\n                var string = \"\"\n                const buf = Buffer.from(msg.payload)\n\n            // Concatenation of the buffer in a string \n                for (let hex of hexFormatValues(buf)) {string = string + hex } \n\n            //msg.payload = string;\n\n// Do NOT Modify! -------------------------------------------------------------\n\n\nplaceholder_start = 0;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nmagic_packet = string.substring(placeholder_start,placeholder_stop);\nmsg.magicpacket = magic_packet;\n\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nversion = parseInt(string.substring(placeholder_start,placeholder_stop));\nmsg.version = version;\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\npacket_type = parseInt(string.substring(placeholder_start,placeholder_stop));\nmsg.packet_type = packet_type;\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\n\nsw_size = string.substring(placeholder_start,placeholder_stop); // Decode Length Of Software Name (wsjt-x vs jtdx vs whatever)\nsw_name_length = placeholder_start  + next_value_length + (parseInt(sw_size) * 2); // Convert hex value to true interger value, double it, and add it to the last hex position of 32\nsw_name = string.substring(32,sw_name_length);      // Get hex of software name, length based on above\n\n    var hex  = sw_name.toString();\n\tvar sw_name_2 = '';\n    for (var n = 0; n < hex.length; n += 2) { sw_name_2 += String.fromCharCode(parseInt(hex.substr(n, 2), 16));}\n\t// Convert software name from hex to ascii \n\t\nmsg.sw_name = sw_name_2;\n\n// END Header\n\n\n// ------------------- Based On STATUS UDP Message\n\nplaceholder_start = sw_name_length;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nunique_key = string.substring(placeholder_start, placeholder_stop);\nunique_key = parseInt(unique_key);\nmsg.unique_key = unique_key;\n\n\n\nmsg.payload = ' New Message ';\n\n\nreturn msg;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":660,"y":260,"wires":[["53d0a7d3.511f28","e53c7800.8d1868"]]},{"id":"2e3e4f72.0798d","type":"function","z":"f848aedb.a536d8","name":"Decoded Status Message","func":"\n//msg.sw_name = Software ID of incoming packet (WSJT/JTDX/ETC) Size is calculated and not static!\n//msg.dial_freq = Dial frequency as reported by UDP Sender\n//msg.mode_name = FT8/FT4/etc, NOT the receiver mode (USB/LSB/Etc.)\n\n// Can be expanded to show more detail based on packet data, however no other useful information\n// exist for this project except dial_freq used as used to sync between GQRX network and RigCtlD for JTDX\n//  to trigger a update for the band-hopping script on band-change/mode-change if done manually.\n\n\n// Do NOT Modify! -------------------------------------------------------------\n        function hexToInt(hex) {\n            if (hex.length % 2 != 0) {\n                hex = \"0\" + hex;\n            }\n            var num = parseInt(hex, 16);\n            var maxVal = Math.pow(2, hex.length / 2 * 8);\n            if (num > maxVal / 2 - 1) {\n                num = num - maxVal\n            }\n            return num;\n        }\n\n\n        // Creation of a function to get the Hex Value from a message\n        function* hexFormatValues(buffer) {\n            for (let x of buffer) {\n                const hex = x.toString(16)\n                yield hex.padStart(2, '0')\n            }\n        }\n\n\n        msg.payload = msg.orig_message;\n\n            // Variable declaration for my loop\n                var string = \"\"\n                const buf = Buffer.from(msg.payload)\n\n            // Concatenation of the buffer in a string \n                for (let hex of hexFormatValues(buf)) {string = string + hex } \n\n            //msg.payload = string;\n\n// Do NOT Modify! -------------------------------------------------------------\n\n\nplaceholder_start = 0;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nmagic_packet = string.substring(placeholder_start,placeholder_stop);\nmsg.magicpacket = magic_packet;\n\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nversion = parseInt(string.substring(placeholder_start,placeholder_stop));\nmsg.version = version;\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\npacket_type = parseInt(string.substring(placeholder_start,placeholder_stop));\nmsg.packet_type = packet_type;\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\n\nsw_size = string.substring(placeholder_start,placeholder_stop); // Decode Length Of Software Name (wsjt-x vs jtdx vs whatever)\nsw_name_length = placeholder_start  + next_value_length + (parseInt(sw_size) * 2); // Convert hex value to true interger value, double it, and add it to the last hex position of 32\nsw_name = string.substring(32,sw_name_length);      // Get hex of software name, length based on above\n\n    var hex  = sw_name.toString();\n\tvar sw_name_2 = '';\n    for (var n = 0; n < hex.length; n += 2) { sw_name_2 += String.fromCharCode(parseInt(hex.substr(n, 2), 16));}\n\t// Convert software name from hex to ascii \n\t\nmsg.sw_name = sw_name_2;\n\n// END Header\n\n\n// ------------------- Based On STATUS UDP Message\n\nplaceholder_start = sw_name_length;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\nunique_key = string.substring(placeholder_start, placeholder_stop);\nunique_key = parseInt(unique_key);\nmsg.unique_key = unique_key;\n\n\n// Decoded Dial Frequency\n\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\ndial_freq = string.substring(placeholder_start,placeholder_stop);\ndial_freq = hexToInt(dial_freq);\nmsg.dial_freq = dial_freq;\n// Decoded Dial Freq\n\n\n// Decoded Mode\nplaceholder_start = placeholder_stop;\nnext_value_length = 8;\nplaceholder_stop = placeholder_start + next_value_length;\n\nmode_size = string.substring(placeholder_start,placeholder_stop); // Decode Length Of Software Name (wsjt-x vs jtdx vs whatever)\nmode_name_length = placeholder_start  + next_value_length + (parseInt(mode_size) * 2); // Convert hex value to true interger value, double it, and add it to the last hex position of 32\n//mode_name = string.substring(32,mode_name_length);      // Get hex of software name, length based on above\nmode_name = string.substring(placeholder_stop,mode_name_length);      // Get hex of software name, length based on above\n\n    var hex2  = mode_name.toString();\n\tvar mode_name_2 = '';\n    for (var o = 0; o < hex2.length; o += 2) { mode_name_2 += String.fromCharCode(parseInt(hex2.substr(o, 2), 16));}\n\t// Convert software name from hex to ascii \n\nmsg.mode_name = mode_name_2;\nplaceholder_stop = mode_name_length;\n// End Decoded Mode Name\n\n\nmsg.payload = ' New Status Message ';\n\n\nreturn msg;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":650,"y":340,"wires":[["8084c530.af563","68b5966c.142418"]]},{"id":"53d0a7d3.511f28","type":"debug","z":"f848aedb.a536d8","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":930,"y":240,"wires":[]},{"id":"8084c530.af563","type":"link out","z":"f848aedb.a536d8","name":"UDP Status Message","links":["bb1f8e36.db4c98"],"x":895,"y":360,"wires":[]},{"id":"e53c7800.8d1868","type":"link out","z":"f848aedb.a536d8","name":"UDP Heartbeat Message","links":[],"x":895,"y":280,"wires":[]},{"id":"68b5966c.142418","type":"debug","z":"f848aedb.a536d8","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":930,"y":320,"wires":[]},{"id":"c81b62e8.5cb908","type":"debug","z":"f848aedb.a536d8","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":930,"y":400,"wires":[]}]
